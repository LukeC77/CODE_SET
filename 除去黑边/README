/***************************************************************    
*                      Architecture
***************************************************************/
We build 2 similar type 2D unboxed arrays: UArray2_T and Bit2_T.
Architecture of them based on Hanson unboxed UArray. We declare 
an outer array as the container to store pointers to inner arrays, 
which stores the actual data. Index for each entry is a pair 
representing column and row.

The sudoku program checks if a 9x9 Sudoku and 3x3 sub Sudokus
solution in a file is correct. We organize the main logic into 
a few parts: reading the input, processing the grid, and 
checking if the solution follows the rules.
We read the Sudoku grid from a file using the Pnmrdr_T reader, 
making sure the format is correct. Then, we store the data in 
a 2D uarray, where each spot represents a cell in the puzzle.
We use functions like validate_sequence to go through each 
row and column to make sure the numbers 1-9 are unique. The 
check_sub_sudoku function checks that each 3x3 subgrid also 
has unique numbers.
If something is wrong with the grid, we exit with EXIT_FAILURE. 
If everything is good, we exit with EXIT_SUCCESS

As for unblackedges, we use pnmrdr to read from input and store
bits into Bit2_T array. We using BFS to search blackedges in four
endges with a queue: (1)If we find a blackedges, convert it to white.
(2)Then we check its neighbours. If black, mark and enqueue the neighbour. 
(3)Then as long as queue is not empty, we continue dequeue, convert
to white, and check dequeued bit's neighbour. Note, marked neightbour
won't be euqueued again.